# 进程与线程

**对于有线程系统**：
进程是资源分配的独立单位
线程是资源调度的独立单位

**对于无线程系统：**
进程是资源调度、分配的独立单位

## 进程通信

### 管道

有名管道：半双工通信，允许无亲缘关系进程间的通讯

* 优点：可以实现任意关系进程间的通信
* 缺点：长期存于系统中，使用不当容易出错，且缓冲区有限

无名管道：半双工通信，只能在具有亲缘关系的进程间使用（父子进程）

* 优点：简单
* 缺点：只能创建在亲缘关系的进程之间，缓冲区有限

### 信号量

一个计数器，可以用来控制多个线程对共享资源的访问

* 优点：可以同步进程
* 缺点：信号量有限

### 信号

用于通知接收进程某个事件已经发生

```
信号9 杀死对应进程
kill -9 id
```

### 消息队列

是一个消息的链表，存放在内核中

* 优点：可以任意进程间通讯，并通过系统调用函数实现消息发送和接受之间的同步，无需考虑同步问题，方便
* 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合

### 共享内存

映射一段能被其他进程访问的公共区域

* 优点：无需复制，快捷，信息量大
* 缺点：需要手动管理竞争的同步问题；

### 套接字

不同计算机间的进程通信

* 优点：传输的数据是字节级的，传输的数据可以自定义，数据量小且效率高
* 缺点：需要对数据进行解析，转换成应用的数据

## 线程间通信

### 锁机制

* 互斥锁/量（mutex）：任意时刻只有一个线程能够访问共享资源，避免数据竞争和不一致性
* 读写锁（reader-writer lock）：多个线程可以同时读取共享资源，只允许一个线程写，并且在写时会阻塞其他读写操作，适用于读多写少场景
* 自旋锁（spin lock）：与互斥锁不同，自旋锁在无法获取锁时不会使线程进入睡眠状态，而是会一直尝试获取锁，直到成功为止（减少线程切换的开销）
* 条件变量（condition）：使一个线程等待某个条件发生，而另一个线程在条件满足时通知等待线程。与互斥锁绑定使用

### 信号量

信号量可以被看作是一个计数器，用来表示可用的资源数量或者可进入临界区的线程数量。根据信号量的值，决定线程继续执行或者等待

### 屏障

屏障是一个同步点，在多线程执行过程中，所有线程必须等待所有其他线程都到达该同步点之后，才能继续向前执行

当线程到达屏障时，会被阻塞，直到所有其他线程都到达屏障为止

## 进程之间私有和共享的资源

- 私有：地址空间、堆、全局变量、栈、寄存器
- 共享：代码段，公共数据，进程目录，进程 ID

## 线程之间私有和共享的资源

- 私有：线程栈，寄存器，程序计数器
- 共享：堆，地址空间，全局变量，静态变量

## 进程和线程区别

* 进程独占地址空间所以导致数据共享复杂，需要借助IPC；但是因为数据是分开的所以同步比较简单

* 多线程因为共享进程数据，所以数据共享简单，但也导致了同步比较复杂

* 并且进程间互不影响所以可靠性比较高，而一个线程挂掉将导致整个进程挂掉

* 还有多进程占用内存多，切换复杂，cpu利用率也比较低，而多线程则占用内存少，切换简单，cpu利用率也比较高

## 死锁

### 原因

多个进程/线程之间，由于彼此之间相互依赖导致的一种状态，彼此都拿着对方需要的资源，而不释放自身资源，从而产生死锁

### 产生条件

* 互斥：一个资源只能被一个进程/线程占有（互斥产生竞争）
* 请求与保持：请求资源被阻塞时不会释放自己持有的资源
* 不可剥夺：无法在进程/线程结束前剥夺它对资源的所有权
* 循环等待：多个进程/线程形成环形等待，都在等待对方释放所需的资源

### 预防

* 死锁预防：破坏上面条件中任意一个即可
* 死锁避免：如银行家算法（预先判断此次分配是否会导致系统进入不安全状态。 如果会进入不安全状态， 就暂时不答应这次请求， 让该进程先阻塞等待）

# 主机字节序与网络字节序

- 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址
- 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址
- 网络字节序使用大端字节序存储

# 编译链接过程

* 预编译：预编译阶段处理预编译指令（#include，#define），生成 `.i` 或 `.ii` 文件

* 编译：编译器进行词法分析、语法分析、语义分析、中间代码生成、目标代码生成、优化。将预编译阶段产生的文件转换成汇编文件，生成 `.s` 文件

* 汇编：把编译阶段生成的汇编文件转换成机械代码，生成 `.o` 文件

* 链接：将所需的静态库、动态库、文件链接成可执行文件 `.out` 文件

## 静态链接和动态链接

### 动态库(DLL)

- 动态库在编译时不会链接到代码中，而是在程序运行时被载入，因此代码体积会比较小，但是每次都要加载，效率低

### 静态库(LIB)

- 静态库在编译时被连接到目标代码中，效率高，但是代码体积大

# 内存管理

## c++内存分区

* 堆：使用malloc、free动态分配和释放空间，能分配较大的内存

* 栈：为函数的局部变量分配内存，能分配较小的内存，系统自动分配释放 

* 全局区：全局区用于存储全局变量和静态变量，这些变量在程序的任何地方都可以访问。

  静态区：静态区用于存储静态变量和静态常量，这些变量的作用域仅限于定义它们的文件或源文件 

* 常量存储区：专门用来存放常量

* 代码区：存放程序的编译后的可执行二进制代码，CPU执行的机器指令，并且是只读的

### 堆栈内存区别

* **栈区（Stack）**：
  * 栈区是由操作系统自动分配和管理的，用于存储函数的参数值、局部变量等数据。栈的管理是由 CPU 的指令来完成的，通常是先进后出（FILO）的结构，因此栈上的内存空间是有限的，而且大小在编译时已经确定
  * 栈区的数据存储方式是连续的，数据的存储和释放速度较快，但是其生存周期受限于函数的调用和返回，函数执行结束时，栈上的局部变量会被自动销毁

* **堆区（Heap）**：
  * 堆区由程序员通过调用像 `malloc()`、`calloc()` 或 `new` 等函数来手动分配和释放内存，因此堆上的内存空间相对于栈来说是动态的，大小不固定，可以根据需要动态增加或释放
  * 堆区的数据存储方式是离散的，数据的存储和释放速度可能较慢，因为堆的分配和释放可能涉及到内存的分配算法和碎片整理等操作

# 多线程

## 多线程编程规则

* **线程的创建和销毁**： 频繁地创建和销毁线程会带来较大的开销。为了减少这种开销，可以使用线程池等技术来重用线程，从而提高性能

* **锁的粒度**： 锁的粒度应该尽量小，以最小化线程之间的竞争和阻塞。过大的锁粒度会导致线程之间的互斥性增加，降低并发性能

* **数据的局部性**： 在多线程编程中，数据的局部性对性能影响很大。尽量将线程访问的数据放置在同一个 CPU 缓存行中，以减少缓存的失效次数，提高数据访问效率

* **任务划分和负载均衡**： 合理划分任务并进行负载均衡是提高多线程应用程序性能的关键。将任务划分为适当的大小，并确保各个线程的负载均衡，以充分利用系统资源

## 线程池

预先创建多个线程并保持在池中，而不是每次需要执行任务时都创建新线程。这样可以减少线程创建和销毁的开销
