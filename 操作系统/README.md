# 进程与线程

**对于有线程系统**：
进程是资源分配的独立单位
线程是资源调度的独立单位

**对于无线程系统：**
进程是资源调度、分配的独立单位

## 进程通信

### 管道

有名管道：半双工通信，允许无亲缘关系进程间的通讯

* 优点：可以实现任意关系进程间的通信
* 缺点：长期存于系统中，使用不当容易出错，且缓冲区有限

无名管道：半双工通信，只能在具有亲缘关系的进程间使用（父子进程）

* 优点：简单
* 缺点：只能创建在亲缘关系的进程之间，缓冲区有限

### 信号量

一个计数器，可以用来控制多个线程对共享资源的访问

* 优点：可以同步进程
* 缺点：信号量有限

### 信号

用于通知接收进程某个事件已经发生

```
信号9 杀死对应进程
kill -9 id
```

### 消息队列

是一个消息的链表，存放在内核中

* 优点：可以任意进程间通讯，并通过系统调用函数实现消息发送和接受之间的同步，无需考虑同步问题，方便
* 缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合

### 共享内存

映射一段能被其他进程访问的公共区域

* 优点：无需复制，快捷，信息量大
* 缺点：需要手动管理竞争的同步问题；

### 套接字

不同计算机间的进程通信

* 优点：传输的数据是字节级的，传输的数据可以自定义，数据量小且效率高
* 缺点：需要对数据进行解析，转换成应用的数据

## 线程间通信

### 锁机制

* 互斥锁/量（mutex）：任意时刻只有一个线程能够访问共享资源，避免数据竞争和不一致性
* 读写锁（reader-writer lock）：多个线程可以同时读取共享资源，只允许一个线程写，并且在写时会阻塞其他读写操作，适用于读多写少场景
* 自旋锁（spin lock）：与互斥锁不同，自旋锁在无法获取锁时不会使线程进入睡眠状态，而是会一直尝试获取锁，直到成功为止（减少线程切换的开销）
* 条件变量（condition）：使一个线程等待某个条件发生，而另一个线程在条件满足时通知等待线程。与互斥锁绑定使用

### 信号量

信号量可以被看作是一个计数器，用来表示可用的资源数量或者可进入临界区的线程数量。根据信号量的值，决定线程继续执行或者等待

### 屏障

屏障是一个同步点，在多线程执行过程中，所有线程必须等待所有其他线程都到达该同步点之后，才能继续向前执行

当线程到达屏障时，会被阻塞，直到所有其他线程都到达屏障为止

## 进程之间私有和共享的资源

- 私有：地址空间、堆、全局变量、栈、寄存器
- 共享：代码段，公共数据，进程目录，进程 ID

## 线程之间私有和共享的资源

- 私有：线程栈，寄存器，程序计数器
- 共享：堆，地址空间，全局变量，静态变量

## 进程和线程区别

* 进程独占地址空间所以导致数据共享复杂，需要借助IPC；但是因为数据是分开的所以同步比较简单

* 多线程因为共享进程数据，所以数据共享简单，但也导致了同步比较复杂

* 并且进程间互不影响所以可靠性比较高，而一个线程挂掉将导致整个进程挂掉

* 还有多进程占用内存多，切换复杂，cpu利用率也比较低，而多线程则占用内存少，切换简单，cpu利用率也比较高

## 死锁

### 原因

多个进程/线程之间，由于彼此之间相互依赖导致的一种状态，彼此都拿着对方需要的资源，而不释放自身资源，从而产生死锁

### 产生条件

* 互斥：一个资源只能被一个进程/线程占有（互斥产生竞争）
* 请求与保持：请求资源被阻塞时不会释放自己持有的资源
* 不可剥夺：无法在进程/线程结束前剥夺它对资源的所有权
* 循环等待：多个进程/线程形成环形等待，都在等待对方释放所需的资源

### 预防

* 死锁预防：破坏上面条件中任意一个即可
* 死锁避免：如银行家算法（预先判断此次分配是否会导致系统进入不安全状态。 如果会进入不安全状态， 就暂时不答应这次请求， 让该进程先阻塞等待）

# 主机字节序与网络字节序

- 大端字节序（Big Endian）：高序字节存储在低位地址，低序字节存储在高位地址
- 小端字节序（Little Endian）：高序字节存储在高位地址，低序字节存储在低位地址
- 网络字节序使用大端字节序存储